# ごっちゃ！(Gotcha)

## 区間DP

区間上の何かを数え上げたい時、dfs(l+1,r) + dfs(l,r-1) - dfs(l+1,r-1) とすれば重複分を引ける

## 選んだ数の履歴が必要なDP

覚えるべき合計が少ないなら bitDP できる。
やりかた : 1 -> "1", 2 -> "10", 3 -> "100" と変換したつもりにすると、bit から数の履歴が戻せる。

## メモ化再帰するときに、メモリが十分でないとき

- 必要な箇所だけメモすることを考慮しよう。
  - たとえば、 互いに素である数の集合 {a_i} のいずれでも割り切れない N <= 10^13 以下の数を求めたいとき。
  - 包除原理で求めることを考えると 2*3*5*…*37*41>10^13 なので、100C12 となり厳しそうだが、
  - a_iを降順にソートして、割った結果 (N/(a_i * a_j * ...))<114514以下の数をメモすれば間に合ってしまう。
- あとはMapで頑張るとか。定数倍重いけど、再帰に出現する数が限られている時に使える。
  - http://codeforces.com/contest/93/problem/E
  - http://dwango2016-honsen.contest.atcoder.jp/tasks/dwango2016final_a


## 円環状に何かが並んでて、隣通しにものを受け渡し、すべてを0にする問題

- 累積和を取る。
- 「同じ数値」をカウントする。N-その最大値が操作回数となる。

## bitDPのテクいろいろ

- bitDPで、dp[A] := 何か(dp[B], dp[C]) , A = B + C, B ^ C = 0 というふうに部分集合同士を組み合わせて答えをだすとき。B に、Aの最下位bit が含まれない場合はスキップすること。ユニークに数え上げ可能
- 部分集合でなくても、何かを足していく形(dp[A] := dp[A-p], 何か(p))でも同様。
  - http://codeforces.com/contest/543/problem/C
  - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2345

## 木DPの計算量

- 子の数の2乗のオーダーで処理するタイプの木DPは、実は O(N^2) である。計算の順番に注意。
  - http://yukicoder.me/problems/234

## 有向グラフ => (強連結成分分解) => DAG / 無向グラフ => (二重辺連結成分分解) => 木

- グラフの問題で、有向の場合は、強連結成分分解でループを含まないDAGにできる。無向の場合は、二重辺連結成分分解で二重連結成分と橋から成る木にできる。
  - (二重辺) http://arc039.contest.atcoder.jp/tasks/arc039_d

- 数列が与えられて、a_i > a_j で a_i % a_j の最大値を求める問題。imos法っぽく imos[x] := x以下の数値の a_i の最大値、としておけば、各mod値で imos[k*mod-1] % mod だけを調べれば良い。
  - http://codeforces.com/contest/484/problem/B

- SegmentTreeの便利な使い方。i = [0, n) を舐めるときにXが最後に出現した位置を持っておくと、
[ i - (何か) , i ) の範囲で出現しなかった数が簡単に分かる。
  - http://arc038.contest.atcoder.jp/tasks/arc038_c


## 塗りつぶしの問題

- 上書きありの塗りつぶし問題。ゴールから考えるとうまくいくパターンが多い
  - http://arc041.contest.atcoder.jp/tasks/arc041_d

- 区間で切ったりマージしたりしたい問題。だいたいTreeSetでなんとかなる


## メビウス関数

- 集合に対して互いに素なペアを数える処理をたくさんやりたいとき。現存する集合に対して、Xで割れる数 d[X] を覚えておいて、包除原理で約数を足したり引いたりするのが常套手段。このとき全ての約数での処理は不要で、 (割れる素数の組み合わせ数 := 1<<素数の種類数) だけでよい。-> メビウス関数
  - http://codeforces.com/contest/547/problem/C

## ユニークな数値の数え上げ

- ユニークな何か(数値)を数え上げたいとき。情報をセットに持ってしまうと、ボクシングあるので重い。そこで、情報を一旦配列に突っ込み、ソートする。そして前の値との差分をカウントしていくと速い。計算量的には微妙だが定数倍が効く。

## 貪欲大全: 点を区間に載せる

- 点たちを区間に対応づける問題。区間の開始・終了と点の出現を座標順にソートし、点出現時に現在有効な区間を TreeSet<> で持つと解ける。このとき、点に対応づける区間は「最も早く終了する区間」を選ぶこと。
  - http://codeforces.com/contest/555/problem/B

## 木DPのコツ

- 木DPに落としこむ問題のパターンとして、「葉を狩って等価な親に縮約できる」という形もある。子のdfsを先に呼んで、その結果を利用し親のDPデータを作成する。
  - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2338


- DAG上で(個数付き)ナップサックDPをしたいとき。一見 O(nW^2) かかりそうだがそれは間違い。各頂点でDP[v] を計算し、それをつながっている頂点に max(DP[to][w], DP[v][w]) で配る。配られた頂点の上で再度ナップサックの処理をすれば、できあがるDPはうまくマージされている。

- 各連結成分にマークが付いた頂点が1つ以上存在するように、木の辺を切るコストを最小化する問題。マークが付いた頂点同士をつないでいい辺の数（自由度）を求め、自由度が0以上になるようキープしつつ、最大全域森を求める。
  - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?i=2390

- Xでソートして尺取しながらその区間上でDPしたいとき。更新式次第では伸ばす(to++)ことは可能だが、縮める(fr++)ことは不可能に思える。だが、dp[idx][何か] := 最小のXの最大値 をもてば、縮めることが可能 （dp[to][何か] のうち、fr より小さいXを無視すれば良い）
 - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2337

## ループのあるゲーム

- 千日手（引き分け）があるゲームの勝者を求める場合。最終状態から確定させていく(これはBFSで可能)と、マークが付かなかったところが引き分け（ゲームがループする）の状態になる。

## ループするDFS => ベルマンフォード

- 思いだせ、DFSがループするときの味方、ベルマンフォード
 - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1178&lang=jp

## 集合から和が k になるセットを調べる

- ΣN=100,000 ぐらいで、(S ⊆ N)ΣS = k のものがあるかどうか調べたいとき。グループ数はたかだか 1+2+…+√N であるため、個数制限ナップサックが使える。計算量は O(N√N)
 - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2370

- 高速ゼータ変換( g[S] = Σf[T]  (T は S を含むすべての集合) を O(n*2^n) で求める。)

- 高速メビウス変換( g(S) = Σ[T⊆S](-1)^|S - T|f(T) となるかたちで、すべてのg(S) を O(n*2^n) で求める。包除原理の途中結果を全部求めたいときに使う。 )
 - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2446


## DPの高速化

- O(n) でDPしたいのに単純な累積和で処理できず、結局O(n^2) になってしまい困るとき。とりあえず、展開してみると簡単な形が見えることが多い。たとえば、dp[K] = a[K] + comb(b, 1) * dp[K-1] + comb(b, 2) * dp[K-2] + … + comb(b, b) * dp[K-b] のように係数に複雑な値が絡むとき。もとめたい dp[N] を 簡単な a[K] の合計で表すことが可能かもしれない(特に、二項係数の場合は、結果も二項係数になる。これは覚えておいて損はないだろう。)
  - http://community.topcoder.com/stat?c=problem_statement&pm=13847

- DPのコスト関数が特殊な場合、高速化の可能性を頭に入れよ。たとえば、区間への最適な「分け方」だったり、N個のものをM個の区間に分解したいときに、コスト関数次第では有効打になりうる。
  - 区間への分解方法 -> Knuth Optimization : O(n^2)
  - N個をM個に -> Divide and Conquer Optimization : O(mnlogn)

### Knuth Optimization

    dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost[i][j])
みたいな形の時、コスト関数が a<b<c<d に対して
    1. cost[a][c] + cost[b][d] <= cost[a][d] + cost[b][c] (:= 分けたほうが安い)
    2. cost[b][c] <= cost[a][d] (:= 区間が短いほうが安い)
の2つの条件を満たすとする。そこで、
    opt[i][j] := dp[i][j] を最小にする k
とおくと、dp[i][j] に対して調べるべきkの区間は
    dp[i][j-1] <= k <= dp[i+1][j]
に限定される(なぜ？)。dfs(i, j) をするときに、自分を最小にしたkを opt[i][j] で計算すれば、親から dfs(0, n-1) を呼ぶことで、この計算は O(n^2) で終わる。
 - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2415

### Divide and Conquer Optimization

    dp[i][j] = min(dp[i-1][k] + cost[k][j])  s.t. k < j
みたいな形の時、コスト関数が a<b<c<d に対して
    1. cost[a][c] + cost[b][d] <= cost[a][d] + cost[b][c] (:= 分けたほうが安い)
    2. cost[b][c] <= cost[a][d] (:= 区間が短いほうが安い)
の2つの条件を満たすとする。そこで、
    opt[i][j] := dp[i][j] を最小にする k
とおくと、
    opt[i][0] <= opt[i][1] <= … opt[i][n]
をみたすはず(なぜ？)。ならば、それぞれの i において、まず dp[i][n/2] をO(n)かけて普通に探索して求めれば、[0, n/2), [n/2+1, n) のそれぞれの区間において、探索すべき範囲が定まることになる。所要時間は区間ごとに O(調べるべき長さ)だが、トータルで 2n を超えない。再帰の深さは log(n) であるため、各i ごとの所要時間は O(nlogn) である。
  - http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2603
  - http://codeforces.com/contest/321/problem/E

## 閉路の数え上げ

- 頂点と辺を複数回通っていいなら、隣接行列のn乗で長さnの閉路が出せる。
- 複数の辺を許さない場合、生起行列（Incidence Matrix != 隣接行列）のランクを考えることで、2^(m-rank)-1 となる。順番に辺を付け加えることを考えると、UnionFindで異なる連結成分に居た場合は m++; rank++、同じ連結成分の場合は m++; rankそのまま、となる。
- http://codeforces.com/contest/91/problem/C

## 二乗の期待値

- 何かの大きさの二乗(の期待値)を求める問題。同一集合に含まれるペアの数の期待値に帰着すると、線形性が使えるようになる。ペアが存在する確率を求めて、それらを合計すればよい。
  - http://community.topcoder.com/stat?c=problem_statement&pm=13915
  - http://codeforces.com/problemset/problem/235/B
- 大きさ k のグループの個数の期待値 dp[k] を(1〜n)についてそれぞれ出して、Σk*k*dp[k] を計算する、という方法も。
  - https://csacademy.com/contest/archive/#task/expected-tree-degrees

## フィボナッチ数列

- 特定の数を含むフィボナッチ数列の部分列。a[0] = A, a[1] = B とおくと、a[k] = kA + lB という形になって、A と a[D] = Z の (A, Z, D) さえ決めれば数列が確定する。

## DPの高速化

- 「何かの後に何かを実行したい」ときはグラフのトポロジカル順序を考えることが多いが、数え上げる場合の計算量は O(2^V) になってしまう。Vが大きい場合は、DPするなどの別の方法を考えよう。
  - http://community.topcoder.com/stat?c=problem_statement&pm=11537

- グラフのマッチングを考えたり、次数が与えられて自己ループを許さないようにN頂点のグラフに辺を貼りたいとき。出次数[i] <= (合計) - 入次数[i] ⇔ 出次数[i] + 入次数[i] <= (合計) を満たすことが、実は必要条件だけでなく十分条件でもある。このことは、ホールの結婚定理から示せる。
  - http://community.topcoder.com/stat?c=problem_statement&pm=11595

- ある数列 A = {a1, a2, .. an} の、特定の条件を満たす並び替えをの総数を数え上げるDP。2行n列の箱を考え、そこに数を埋めていくとうまくいくことが多い。dp[位置][1行目未確定][2行目未確定][注目したい属性] := 総数 という形になり、更新式は
  dp[i+1][u][d] += dp[i][u][d] (そのままマッチ)
  dp[i+1][u][d] += u * dp[i][u][d] (2行目と1行目スルーしたやつがマッチ)
  dp[i+1][u][d] += d * dp[i][u][d] (1行目と2行目スルーしたやつがマッチ)
  dp[i+1][u-1][d-1] += u * d * dp[i][u][d] (それぞれスルー済にマッチ)
  dp[i+1][u+1][d+1] += dp[i][u][d] (スルー。自由度が1増える)
という感じに。このとき、u と d の動き方は等しいため、一つにまとめられる。
 - http://apps.topcoder.com/stat?c=problem_statement&pm=10849&rd=14723

-
 - http://community.topcoder.com/stat?c=problem_statement&pm=11766

- 答え S = (なんたら) を最小化／最大化したいとき。なんたらの中身が複雑な場合、Sを決め打ちし二分探索しよう。にぶたん中では S を定数とみなし、 最小化なら f(x,S) >= (定数)、最大化なら f(x,S) <= (定数) というかんじに式変形。f(x,S) が大きく／小さくなるように貪欲に選択、もしくはDPをする。
 - http://community.topcoder.com/stat?c=problem_statement&pm=11454

- 有向オイラー(閉)路の存在条件。連結かつ、各vについて (入次数)-(出次数) = 0 が必要十分条件。
 - http://community.topcoder.com/stat?c=problem_statement&pm=11217

- Dilworth's theorem : 推移閉包をとったDAGの最小パス被覆は、グラフの独立点集合(どの二点も互いに行き来不可)の数に等しい。推移閉包か否かに限らず、最小パス被覆は (頂点数) - (DAGを2部グラフ化した時の最大マッチング) で求まる。
また、(最小点被覆)は二部グラフでないと解けない。
* (パス被覆) := 辺による全点の被覆  =>   (最小パス被覆) + (最大マッチング) := |V|
* (点被覆)    := 頂点による全辺の被覆 => (最小点被覆) + (最大安定集合) := |V|
* (最大安定集合)

- 木から一部の頂点をランダムにK個選んで作られる部分木の長さ合計期待値は、辺が作られる確率の合計と等しい。部分木の直径の期待値は、直径(a, b)を決め打ちし、直径以内の候補点を(a,b)がlex-smallestになるように列挙し、そこからK-2個選んだのを数え上げた合計になる。そして、これらが分かれば木からK点を訪問する最短距離が求まる。
 - http://community.topcoder.com/stat?c=problem_statement&pm=12305

- 文字列の典型集。
  - 最長回文 -> manacharでO(N)

  - 相異なる部分文字列の数
  - 指定の文字列が部分文字列として登場する数
  -

## 割り振りが実数な以下の制約を充足する問題

- a[0]*X[0]+a[1]*X[1]+...+a[n-1]*X[n-1] >= p
- a[0]*Y[0]+a[1]*Y[1]+...+a[n-1]*Y[n-1] >= q

を満たす A = Σa を最小化。
凸法を取ると、a を合計 1 割り当てた時に進める範囲が求まる。

## ゲーム

- 勝敗
  - 最終状態からBFSで確定
  - DP(Grundy数)
- スコア差の最大化
  - 最終状態を決め、そこに到達する先手／後手の動きを考える
  - 先手後手が独立に動ける
