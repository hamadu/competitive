# 全般

- 問題読みなおし
- 手で解いてサンプルと比べる
- 諦める

# 最大・最小化

- 答え決め打ち二分探索
- 貪欲(上位k個から全探索)
 - 最適な最終状態を考え、必要条件を探す
- DP
- グラフ化
- 最終状態から元に戻す
- 式を書いて直線の形ならConvex Hull Trick

# 数え上げ

- 分解して掛け算(素数ごと,連結成分ごと,縦と横)
- ダブリング

# 構築ゲー(答えを何か一つ出す)

- 手で頑張る
- 法則を探す
- 時間いっぱいランダムに生成してみる

# ゲーム

- min-max法(DP)
- 千日手（引き分け）があるゲーム => 最終状態から確定させていく。マークが付かなかったところが引き分け
- 手で解くor全探索で法則を探す


# グラフ

## 木

- 線で考える
- 木DP
- 葉を縮約
- HL分解
- 直径は中心を通る

## 木とは限らない無向グラフ

- 木に帰着する(=> 二重辺連結成分分解)
- 橋・関節点
- 実は二部グラフ？

## 有向グラフ

- DAGに帰着する(=> 強連結成分分解)

# 数論

- 素数ごとに考える(=> 素因数分解)
- bitごとに考える

# DP

- 状態は十分か？
- もらうDPの形にして最小値を探す部分を高速化
- ターン数が多い => ダブリング
- 制約ゆるめ => 全探索に近いDPをする？(履歴をk個まで持つ,etc)

## 区間への分解 => Knuth Optimization : O(n^2)

-  dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost[i][j])

## N個をM個に => Divide and Conquer Optimization : O(mnlogn)

- dp[i][j] = min(dp[i-1][k] + cost[k][j])  s.t. k < j

## 木DP

- 子の数の2乗のオーダーで処理するタイプの木DPは O(N^2)


